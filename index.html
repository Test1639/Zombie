<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Enhanced 2.5D Shooter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      background: #000;
      overscroll-behavior: none;
      touch-action: none;
    }
    canvas {
      width: 100vw !important;
      height: 100vh !important;
      display: block;
    }
    #hud-gun {
      position: absolute;
      bottom: -10px;
      right: 40px;
      width: 340px;
      height: auto;
      pointer-events: none;
      z-index: 10;
      transform: scale(1.05);
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: sans-serif;
      font-size: 14px;
      z-index: 10;
    }
    #mobile-controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      z-index: 10;
    }
    .joystick {
      width: 80px;
      height: 80px;
      background: rgba(255,255,255,0.2);
      border-radius: 50%;
      position: absolute;
    }
    #move-joystick {
      left: 0;
    }
    #look-joystick {
      left: 100px;
    }
    #shoot-button {
      position: absolute;
      right: 20px;
      bottom: 20px;
      width: 80px;
      height: 80px;
      background: rgba(255,0,0,0.3);
      border-radius: 50%;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="info">Touch right side to look, left side to move, red button to shoot</div>
  <div id="mobile-controls">
    <div id="move-joystick" class="joystick"></div>
    <div id="look-joystick" class="joystick"></div>
  </div>
  <div id="shoot-button"></div>
  <img id="hud-gun" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACt..." alt="Gun HUD" />
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
  <script>
    // Game state
    const game = {
      camera: null,
      scene: null,
      renderer: null,
      controls: {
        forward: false,
        back: false,
        left: false,
        right: false,
        lookX: 0,
        lookY: 0,
        moveX: 0,
        moveY: 0
      },
      bullets: [],
      enemies: [],
      bulletSpeed: 0.5,
      bulletSize: 0.08,
      lastShotTime: 0,
      fireDelay: 300,
      playerHealth: 100,
      score: 0,
      gameOver: false
    };

    // Initialize game
    init();
    animate();

    function init() {
      // Setup Three.js scene
      game.scene = new THREE.Scene();
      game.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      game.camera.position.set(0, 1.6, 5);

      game.renderer = new THREE.WebGLRenderer({ antialias: true });
      game.renderer.setPixelRatio(window.devicePixelRatio);
      game.renderer.setClearColor(0x000000, 1);
      game.renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(game.renderer.domElement);

      // Create environment
      createEnvironment();
      
      // Create enemies
      createEnemies();

      // Setup controls
      setupControls();

      // Handle window resize
      window.addEventListener('resize', onWindowResize);
    }

    function createEnvironment() {
      // Floor
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(100, 100),
        new THREE.MeshBasicMaterial({ color: 0x222222 })
      );
      floor.rotation.x = -Math.PI / 2;
      game.scene.add(floor);

      // Walls
      const wallMat = new THREE.MeshBasicMaterial({ color: 0x4444aa });
      for (let i = 0; i < 20; i++) {
        const wall = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), wallMat);
        wall.position.set(Math.random() * 20 - 10, 1, -i * 5);
        game.scene.add(wall);
      }
    }

    function createEnemies() {
      const enemyTex = new THREE.TextureLoader().load('https://i.imgur.com/fYDOk8Y.png');
      const enemyMat = new THREE.SpriteMaterial({ map: enemyTex });
      
      for (let i = 0; i < 5; i++) {
        createEnemy(enemyMat, Math.random() * 10 - 5, -i * 10 - 5);
      }
    }

    function createEnemy(material, x, z) {
      const enemy = {
        sprite: new THREE.Sprite(material),
        health: 3,
        speed: 0.02,
        position: new THREE.Vector3(x, 1.5, z)
      };
      
      enemy.sprite.position.copy(enemy.position);
      enemy.sprite.scale.set(1.5, 1.5, 1.5);
      game.scene.add(enemy.sprite);
      game.enemies.push(enemy);
    }

    function setupControls() {
      // Keyboard controls
      document.addEventListener('keydown', e => {
        if (e.key === 'w') game.controls.forward = true;
        if (e.key === 's') game.controls.back = true;
        if (e.key === 'a') game.controls.left = true;
        if (e.key === 'd') game.controls.right = true;
      });
      
      document.addEventListener('keyup', e => {
        if (e.key === 'w') game.controls.forward = false;
        if (e.key === 's') game.controls.back = false;
        if (e.key === 'a') game.controls.left = false;
        if (e.key === 'd') game.controls.right = false;
      });

      // Mouse controls
      document.addEventListener('mousemove', e => {
        if (e.buttons === 1) {
          game.camera.rotation.y -= e.movementX * 0.002;
        }
      });

      // Touch controls
      setupTouchControls();
      
      // Shoot button
      document.addEventListener('click', shootBullet);
    }

    function setupTouchControls() {
      const moveJoystick = document.getElementById('move-joystick');
      const lookJoystick = document.getElementById('look-joystick');
      const shootButton = document.getElementById('shoot-button');
      
      let moveTouchId = null;
      let lookTouchId = null;
      
      // Move joystick
      moveJoystick.addEventListener('touchstart', e => {
        if (moveTouchId === null) {
          moveTouchId = e.touches[0].identifier;
          updateMoveJoystick(e.touches[0]);
        }
        e.preventDefault();
      });
      
      document.addEventListener('touchmove', e => {
        for (let i = 0; i < e.changedTouches.length; i++) {
          const touch = e.changedTouches[i];
          if (touch.identifier === moveTouchId) {
            updateMoveJoystick(touch);
          }
          if (touch.identifier === lookTouchId) {
            updateLookJoystick(touch);
          }
        }
        e.preventDefault();
      });
      
      document.addEventListener('touchend', e => {
        for (let i = 0; i < e.changedTouches.length; i++) {
          const touch = e.changedTouches[i];
          if (touch.identifier === moveTouchId) {
            moveTouchId = null;
            game.controls.moveX = 0;
            game.controls.moveY = 0;
          }
          if (touch.identifier === lookTouchId) {
            lookTouchId = null;
            game.controls.lookX = 0;
            game.controls.lookY = 0;
          }
        }
      });
      
      // Look joystick
      lookJoystick.addEventListener('touchstart', e => {
        if (lookTouchId === null) {
          lookTouchId = e.touches[0].identifier;
          updateLookJoystick(e.touches[0]);
        }
        e.preventDefault();
      });
      
      // Shoot button
      shootButton.addEventListener('touchstart', e => {
        shootBullet();
        e.preventDefault();
      });
      
      function updateMoveJoystick(touch) {
        const rect = moveJoystick.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        game.controls.moveX = (touch.clientX - centerX) / (rect.width / 2);
        game.controls.moveY = (touch.clientY - centerY) / (rect.height / 2);
        
        // Normalize
        const len = Math.sqrt(game.controls.moveX**2 + game.controls.moveY**2);
        if (len > 1) {
          game.controls.moveX /= len;
          game.controls.moveY /= len;
        }
      }
      
      function updateLookJoystick(touch) {
        const rect = lookJoystick.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        game.controls.lookX = (touch.clientX - centerX) / (rect.width / 2);
        game.controls.lookY = (touch.clientY - centerY) / (rect.height / 2);
      }
    }

    function shootBullet() {
      if (game.gameOver) return;
      
      const now = performance.now();
      if (now - game.lastShotTime < game.fireDelay) return;
      game.lastShotTime = now;

      const bulletGeo = new THREE.SphereGeometry(game.bulletSize, 8, 8);
      const bulletMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      const bullet = new THREE.Mesh(bulletGeo, bulletMat);

      // Muzzle offset
      const muzzleOffset = new THREE.Vector3(0, -0.15, -0.5).applyQuaternion(game.camera.quaternion);
      bullet.position.copy(game.camera.position).add(muzzleOffset);

      const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(game.camera.quaternion).normalize();
      bullet.velocity = direction.multiplyScalar(game.bulletSpeed);
      
      // Store bullet reference for collision detection
      const bulletObj = {
        mesh: bullet,
        velocity: bullet.velocity,
        position: bullet.position.clone()
      };
      
      game.bullets.push(bulletObj);
      game.scene.add(bullet);
      
      // Check for hits immediately in case enemy is very close
      checkBulletCollisions(bulletObj);
    }

    function updateBullets() {
      for (let i = game.bullets.length - 1; i >= 0; i--) {
        const bullet = game.bullets[i];
        bullet.position.add(bullet.velocity);
        bullet.mesh.position.copy(bullet.position);
        
        // Remove bullets that are too far
        if (bullet.position.distanceTo(game.camera.position) > 50) {
          game.scene.remove(bullet.mesh);
          game.bullets.splice(i, 1);
        }
        
        // Check for collisions
        checkBulletCollisions(bullet);
      }
    }

    function checkBulletCollisions(bullet) {
      for (let i = game.enemies.length - 1; i >= 0; i--) {
        const enemy = game.enemies[i];
        const distance = bullet.position.distanceTo(enemy.position);
        
        if (distance < 1) { // Hit detection radius
          enemy.health--;
          
          // Remove bullet
          game.scene.remove(bullet.mesh);
          game.bullets.splice(game.bullets.indexOf(bullet), 1);
          
          if (enemy.health <= 0) {
            // Enemy killed
            game.scene.remove(enemy.sprite);
            game.enemies.splice(i, 1);
            game.score += 100;
            
            // Spawn new enemy
            if (game.enemies.length < 3) {
              const enemyMat = new THREE.SpriteMaterial({ 
                map: new THREE.TextureLoader().load('https://i.imgur.com/fYDOk8Y.png') 
              });
              createEnemy(
                enemyMat, 
                Math.random() * 20 - 10, 
                game.camera.position.z - 20 - Math.random() * 10
              );
            }
          }
          break;
        }
      }
    }

    function updatePlayer() {
      if (game.gameOver) return;
      
      // Movement from keyboard
      const dir = new THREE.Vector3();
      if (game.controls.forward) dir.z -= 0.1;
      if (game.controls.back) dir.z += 0.1;
      if (game.controls.left) dir.x -= 0.1;
      if (game.controls.right) dir.x += 0.1;
      
      // Movement from touch joystick
      dir.x += game.controls.moveX * 0.1;
      dir.z += game.controls.moveY * 0.1;
      
      dir.applyAxisAngle(new THREE.Vector3(0, 1, 0), game.camera.rotation.y);
      game.camera.position.add(dir);
      
      // Rotation from touch joystick
      game.camera.rotation.y -= game.controls.lookX * 0.05;
      
      // Check enemy collisions
      for (const enemy of game.enemies) {
        const distance = game.camera.position.distanceTo(enemy.position);
        if (distance < 1.5) {
          game.playerHealth -= 0.5;
          if (game.playerHealth <= 0) {
            gameOver();
          }
        }
      }
    }

    function gameOver() {
      game.gameOver = true;
      alert(`Game Over! Your score: ${game.score}`);
      // Reset game
      setTimeout(() => {
        location.reload();
      }, 1000);
    }

    function onWindowResize() {
      game.camera.aspect = window.innerWidth / window.innerHeight;
      game.camera.updateProjectionMatrix();
      game.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      
      updatePlayer();
      updateBullets();
      game.renderer.render(game.scene, game.camera);
    }
  </script>
</body>
</html>
